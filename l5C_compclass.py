'''
C. Каждому по компьютеру
Ограничение времени	1 секунда
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В новом учебном году на занятия в компьютерные классы Дворца Творчества Юных пришли учащиеся, которые были разбиты
на N групп. В i-й группе оказалось Xi человек. Тут же перед директором встала серьезная проблема: как распределить
группы по аудиториям. Во дворце имеется M ≥ N аудиторий, в j-й аудитории имеется Yj компьютеров. Для занятий необходимо,
чтобы у каждого учащегося был компьютер и еще один компьютер был у преподавателя. Переносить компьютеры из одной
аудитории в другую запрещается. Помогите директору!
Напишите программу, которая найдет, какое максимальное количество групп удастся одновременно распределить по аудиториям,
чтобы всем учащимся в каждой группе хватило компьютеров, и при этом остался бы еще хотя бы один для учителя.

Формат ввода
На первой строке входного файла расположены числа N и M (1 ≤ N ≤ M ≤ 1000).
На второй строке расположено N чисел — X1, …, XN (1 ≤ Xi ≤ 1000 для всех 1 ≤ i ≤ N).
На третьей строке расположено M чисел Y1, ..., YM (1 ≤ Yi ≤ 1000 для всех 1 ≤ i ≤ M).

Формат вывода
Выведите на первой строке число P - количество групп, которые удастся распределить по аудиториям.
На второй строке выведите распределение групп по аудиториям – N чисел, i-е число должно соответствовать номеру аудитории,
в которой должна заниматься i-я группа. (Нумерация как групп, так и аудиторий, начинается с 1). Если i-я группа осталась
без аудитории, i-е число должно быть равно 0. Если допустимых распределений несколько, выведите любое из них.

Пример 1
Ввод	Вывод
1 1
1
2
1
1
'''
n, m = map(int, input().split())
x = list(map(int, input().split()))
y = list(map(int, input().split()))
xgroups = [(x[i], i+1) for i in range(n)]
yclass = [(y[i], i+1) for i in range(m)]
xgroups.sort(key= lambda x: x[0])
yclass.sort(key= lambda y: y[0])
ans = [(0,0)] * n
curry = 0
countgroups = 0
for i in range(n):
    j = curry
    if (j < m):
        while (j < m) and (yclass[j][0] < xgroups[i][0] + 1):
            j += 1
        if (j < m):
            ans[i] = (yclass[j][1], xgroups[i][1])
            countgroups += 1
            curry = j + 1
    else:
        ans[i] = (0, xgroups[i][1])
ans.sort(key = lambda x: x[1])
s = [str(x[0]) for x in ans]
print(countgroups, ' '.join(s), sep='\n')

'''
3 4
6 7 5
6 8 7 4

4 3
7 5 8 6
7 6 8

3 4
5 6 7
1 2 3 4
'''
