'''
C. Минимальное покрытие
Ограничение времени	3 секунды
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
На прямой задано некоторое множество отрезков с целочисленными координатами концов [Li, Ri].
Выберите среди данного множества подмножество отрезков, целиком покрывающее отрезок [0, M],
(M — натуральное число), содержащее наименьшее число отрезков.

Формат ввода
В первой строке указана константа M (1 ≤ M ≤ 5000). В каждой последующей строке записана пара чисел
Li и Ri (Li, Ri ≤ 50000), задающая координаты левого и правого концов отрезков. Список завершается
парой нулей. Общее число отрезков не превышает 100 000.

Формат вывода
В первой строке выходного файла выведите минимальное число отрезков, необходимое для покрытия
отрезка [0; M]. Далее выведите список покрывающего подмножества, упорядоченный по возрастанию
координат левых концов отрезков. Список отрезков выводится в том же формате, что и во входe.
Завершающие два нуля выводить не нужно. Если покрытие отрезка [0, M] исходным множеством
отрезков [Li, Ri] невозможно, то следует вывести единственную фразу “No solution”.
Пример 1
Ввод
1
-1 0
-5 -3
2 5
0 0
Вывод
No solution

Пример 2
Ввод
1
-1 0
0 1
0 0
Вывод
1
0 1
Ещё входные данные для тестов:
3
-1 0
-5 -3
2 5
0 2
0 0
----
4
-1 0
-5 -3
-1 2
2 6
0 0
'''
m = int(input())
segments = []
l, r = map(int, input().split())
while (l, r) != (0, 0):
    segments.append((l, r))
    l, r = map(int, input().split())
segments.sort()
left = 0
right = 0
ans_set = []
cur = (0, 0)
for p in segments:
    if p[0] > left:
        ans_set.append(cur)
        left = cur[1]
        if left >= m:
            break
    if p[0] <= left and p[1] > right:
        cur = p
        right = p[1]
if left < m:
    ans_set.append(cur)
    left = cur[1]
if left < m:
    print('No solution')
else:
    print(len(ans_set))
    for p in ans_set:
        print(*p)
